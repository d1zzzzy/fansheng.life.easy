[{"title":"代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素","date":"2023-11-29T07:37:41.000Z","date_formatted":{"ll":"2023年11月29日","L":"2023/11/29","MM-DD":"11-29"},"updated":"2023-11-29T10:44:14.495Z","content":"代码随想录算法训练营第一天\n\n算法: 在数学（算学）和计算机科学之中，指一个被定义好的、计算机可施行其指示的有限步骤或次序，常用于计算、数据处理和自动推理。算法是有效方法，包含一系列定义清晰的指令，并可于有限的时间及空间内清楚的表述出来。\n\n今天开始复习算法内容，顺便结合算法题回想一下数学知识。格式大概为：算法题目、数学联想、思路、代码、复杂度分析。\n二分查找\n前提/已知\n一般来说，二分查找依赖于以下前提或已知：\n\n数组是升序的\n数组是有限的\n\n查找某个 target 可以当成求出 y = target 在 x ∈ [0, n) 区间内与函数的交点。\n\n数学联想\n由于数组下标是递增的，数组本身也是递增的，所以可以把下标当成 x 轴\n数组元素即可以看成一个在某个区域内关于某个映射（函数）的值域\n查找的目标值即为求 y = target 与函数的交点\n数学意义也就是解方程 f(x) - target = 0\n但是这个映射是随机的，所以无法通过解方程的方式求出交点，只能用类似 中值定理 的方式求出交点\n\n思路\n下标值范围为: [0, length) = [0, length - 1] (下标为整数);\n\n如果左侧端点已经比目标值大，此时可以直接返回 -1\n取中点的值判断\n3. 如果该值等于目标值，则得到结果\n4. 如果该值比目标值大，则目标值在 [0, mid] 区间内， 重复步骤 2\n5. 如果该值比目标值小，则目标值在 [mid, length - 1] 区间内， 重复步骤 2\n\n解法一：区域取 [0, length - 1]\n1234567891011121314151617181920function search(nums: number[], target: number): number &#123;\t// 初始区间范围\tlet left = 0;\tlet right = nums.length - 1;  // 由于区间范围是 [0, length - 1]，所以当 left === right 时，区间范围为 [left, left]，即只有一个元素\twhile (left &lt;= right) &#123;    // 取中点\t\tconst mid = left + ((right - left) &gt;&gt; 1);\t\tif (nums[mid] === target) &#123;\t\t\treturn mid;\t\t&#125; else if (nums[mid] &gt; target) &#123;\t\t\tright = mid - 1;\t\t&#125; else &#123;\t\t\tleft = mid + 1;\t\t&#125;\t&#125;\treturn -1;&#125;\n解法二：区域取 [0, length)\n123456789101112131415161718192021function search(nums: number[], target: number): number &#123;\t// 初始区间范围\tlet left = 0;\tlet right = nums.length;  // 由于区间范围是 [0, length)，所以退出条件是当 left === right - 1 时，区间范围为 [left, right)，即只有一个元素\twhile (left &lt; right) &#123;    // 取中点\t\tconst mid = left + ((right - left) &gt;&gt; 1);\t\tif (nums[mid] === target) &#123;\t\t\treturn mid;\t\t&#125; else if (nums[mid] &gt; target) &#123;\t\t\t// 区别：因为右边界是开区间下一轮不会进入判断，所以这里不需要减一\t\t\tright = mid;\t\t&#125; else &#123;\t\t\tleft = mid + 1;\t\t&#125;\t&#125;\treturn -1;&#125;\n复杂度分析\n两种解法的空间和时间复杂度都是:\n\n空间复杂度：O(1)\n时间复杂度：O(logn)\n\n移除元素\n思路\n移除数组中的某个元素，可以看成是把数组中的某个元素移动到数组末尾，然后把数组末尾的元素删除。\n解法一：暴力解法\n暴力解法的本质是：遍历数组，如果当前元素等于目标值，则把当前元素后面的元素向前移动一位，然后数组长度减一，并且重复这个操作。\n12345678910111213141516function removeElement(nums: number[], val: number): number &#123;  // 遍历数组  for (let i = 0; i &lt; nums.length; i++) &#123;\t  // 如果当前元素等于目标值    if (nums[i] === val) &#123;      for (let j = i + 1; j &lt; nums.length; j++) &#123;        nums[j - 1] = nums[j];      &#125;      i--;      nums.length--;    &#125;  &#125;  return nums.length;&#125;\n复杂度分析\n\n空间复杂度：O(1)\n时间复杂度：O(n^2)\n\n解法二：快慢指针\n双指针解法的本质：交换数组中两项的位置，而至于应该删除的数据全会被移到数组末端，如果需要删除的话，统计一下目标值的数量然后 arr.length = arr.length - sum 即可。\n1234567891011121314151617181920function removeElement(nums: number[], val: number): number &#123;\t// 慢指针\tlet slow = 0;\t// 快指针\tlet fast = 0;\twhile (fast &lt; nums.length) &#123;\t\t// 如果快指针指向的元素不等于目标值\t\tif (nums[fast] !== val) &#123;\t\t\t// 把快指针指向的元素赋值给慢指针指向的元素\t\t\tnums[slow] = nums[fast];\t\t\t// 慢指针向后移动一位\t\t\tslow++;\t\t&#125;\t\t// 快指针向后移动一位\t\tfast++;\t&#125;\treturn slow;&#125;\n复杂度分析\n\n空间复杂度：O(1)\n时间复杂度：O(n)\n\n","thumbnail":"/images/code-camp-day01.png","plink":"https://d1zzzzy.github.io/fansheng.life.easy/2023/11/29/CodeCampDay01/"},{"title":"About","date":"2023-11-29T10:55:16.001Z","updated":"2023-11-29T10:55:16.001Z","content":"代我娓娓道来\n"},{"title":"Project","date":"2023-07-19T01:59:51.519Z","updated":"2023-07-19T01:59:51.519Z","content":""}]